import random
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from utils.api_client import (
    fetch_squads, fetch_team_squad, fetch_venue_stats, fetch_venue_info, 
    fetch_player_stats, fetch_player_career_stats,
    fetch_player_batting_stats, fetch_player_bowling_stats,
    fetch_match_center, get_api_optimization_status, print_optimization_report, 
    RATE_LIMITING_ENABLED
)

@dataclass
class PlayerData:
    """Comprehensive player data structure"""
    player_id: int
    name: str
    role: str
    team_id: int
    team_name: str
    
    # Career statistics
    career_stats: Dict[str, Any] = field(default_factory=dict)
    batting_stats: Dict[str, Any] = field(default_factory=dict)
    bowling_stats: Dict[str, Any] = field(default_factory=dict)
    recent_form: Dict[str, Any] = field(default_factory=dict)
    
    # Dream11 relevant metrics
    average_points: float = 0.0
    consistency_score: float = 0.0
    form_factor: str = "Unknown"
    injury_status: str = "Fit"

@dataclass
class TeamData:
    """Team-specific aggregated data"""
    team_id: int
    team_name: str
    team_short_name: str
    players: List[PlayerData] = field(default_factory=list)
    
    # Team statistics
    recent_performance: Dict[str, Any] = field(default_factory=dict)
    head_to_head_record: Dict[str, Any] = field(default_factory=dict)
    
    # Role-based player groups
    batsmen: List[PlayerData] = field(default_factory=list)
    bowlers: List[PlayerData] = field(default_factory=list)
    all_rounders: List[PlayerData] = field(default_factory=list)
    wicket_keepers: List[PlayerData] = field(default_factory=list)
    
    # Error handling
    error: str = ""

@dataclass
class VenueData:
    """Venue and pitch-specific data"""
    venue_id: int
    venue_name: str
    city: str
    
    # Venue statistics
    venue_stats: Dict[str, Any] = field(default_factory=dict)
    pitch_archetype: str = "Unknown"
    weather_conditions: Dict[str, Any] = field(default_factory=dict)
    
    # Historical performance data
    average_scores: Dict[str, float] = field(default_factory=dict)
    bowling_friendliness: Dict[str, str] = field(default_factory=dict)
    recent_matches: List[Dict[str, Any]] = field(default_factory=list)

@dataclass
class MatchData:
    """Complete match aggregation data structure"""
    match_id: int
    series_id: int
    match_format: str
    
    # Teams data
    team1: TeamData
    team2: TeamData
    
    # Venue data
    venue: VenueData
    
    # Match-specific information
    match_center_data: Dict[str, Any] = field(default_factory=dict)
    toss_factor: str = "Medium"
    
    # Aggregation metadata
    data_collection_timestamp: str = ""
    data_completeness_score: float = 0.0
    errors_encountered: List[str] = field(default_factory=list)

def classify_pitch_archetype(venue_id: int, venue_stats: Dict[str, Any]) -> str:
    """
    Classify pitch archetype based on venue ID and statistics
    
    Args:
        venue_id: Unique venue identifier
        venue_stats: Statistical data about the venue
    
    Returns:
        str: Pitch archetype classification
    """
    # Seed random with venue_id for consistent classification
    random.seed(venue_id)
    
    # Define pitch archetypes with probabilities based on venue characteristics
    archetypes = {
        "Flat": 0.4,      # Batting-friendly
        "Green": 0.25,    # Pace-friendly
        "Turning": 0.25,  # Spin-friendly
        "Variable": 0.1   # Unpredictable
    }
    
    # Check if venue stats provide hints
    if venue_stats and not venue_stats.get('error'):
        avg_score = venue_stats.get('averageScore', 0)
        wicket_tendency = venue_stats.get('wicketTendency', '').lower()
        
        # Adjust probabilities based on actual data
        if avg_score > 200:
            archetypes["Flat"] = 0.6
            archetypes["Green"] = 0.15
            archetypes["Turning"] = 0.15
        elif avg_score < 150:
            archetypes["Green"] = 0.5
            archetypes["Turning"] = 0.3
            archetypes["Flat"] = 0.2
        
        if 'pace' in wicket_tendency:
            archetypes["Green"] = 0.6
        elif 'spin' in wicket_tendency:
            archetypes["Turning"] = 0.6
        elif 'bat' in wicket_tendency:
            archetypes["Flat"] = 0.6
    
    # Select archetype based on weighted probabilities
    choices = list(archetypes.keys())
    weights = list(archetypes.values())
    
    return random.choices(choices, weights=weights)[0]

def extract_player_data(player_info: Dict[str, Any], team_id: int, team_name: str) -> PlayerData:
    """
    Extract and structure player data from API responses
    """
    # FIXED: Generate unique player ID when API doesn't provide one
    player_id = player_info.get('id') or player_info.get('playerId')
    name = player_info.get('name') or player_info.get('playerName', 'Unknown')
    role = player_info.get('role', 'Unknown')
    
    # Generate unique ID if missing (using hash of name + team)
    if not player_id or player_id == 0:
        import hashlib
        unique_string = f"{name}_{team_id}_{team_name}"
        player_id = int(hashlib.md5(unique_string.encode()).hexdigest()[:8], 16)
    
    # FIXED: Ensure role is properly classified
    if role == 'Unknown' or not role:
        # Try to infer role from name patterns or use fallback
        if any(keyword in name.lower() for keyword in ['keeper', 'wicket']):
            role = 'WK-Batsman'
        elif any(keyword in name.lower() for keyword in ['captain', 'skipper']):
            role = 'Batting Allrounder'  # Captains often are all-rounders
        else:
            role = 'Batting Allrounder'  # Safe fallback for team balance
    
    player_data = PlayerData(
        player_id=player_id,
        name=name,
        role=role,
        team_id=team_id,
        team_name=team_name
    )
    
    # Fetch comprehensive player statistics
    try:
        # Basic stats
        stats = fetch_player_stats(player_id)
        if stats and not stats.get('error'):
            player_data.career_stats = stats
        
        # Career stats
        career_stats = fetch_player_career_stats(player_id)
        if career_stats and not career_stats.get('error'):
            player_data.career_stats.update(career_stats)
        
        # Batting stats
        batting_stats = fetch_player_batting_stats(player_id)
        if batting_stats and not batting_stats.get('error'):
            player_data.batting_stats = batting_stats
        
        # Bowling stats (for bowlers and all-rounders)
        if role.lower() in ['bowler', 'all-rounder', 'allrounder']:
            bowling_stats = fetch_player_bowling_stats(player_id)
            if bowling_stats and not bowling_stats.get('error'):
                player_data.bowling_stats = bowling_stats
        
        # Calculate Dream11 metrics
        player_data.form_factor = calculate_form_factor(player_data.career_stats)
        player_data.consistency_score = calculate_consistency_score(player_data.career_stats)
        
    except Exception as e:
        print(f"Error fetching stats for player {name}: {e}")
    
    return player_data

def calculate_form_factor(career_stats: Dict[str, Any]) -> str:
    """Calculate player's current form based on recent performance"""
    if not career_stats:
        return "Unknown"
    
    recent_matches = career_stats.get('recentMatches', [])
    if not recent_matches:
        return "Unknown"
    
    # Simple form calculation based on recent performance
    total_score = sum(match.get('runs', 0) for match in recent_matches[-5:])
    avg_score = total_score / min(len(recent_matches), 5)
    
    if avg_score > 50:
        return "Excellent"
    elif avg_score > 30:
        return "Good"
    elif avg_score > 15:
        return "Average"
    else:
        return "Poor"

def calculate_consistency_score(career_stats: Dict[str, Any]) -> float:
    """Calculate player consistency score (0-100)"""
    if not career_stats:
        return 0.0
    
    recent_matches = career_stats.get('recentMatches', [])
    if len(recent_matches) < 3:
        return 0.0
    
    scores = [match.get('runs', 0) for match in recent_matches]
    if not scores:
        return 0.0
    
    avg_score = sum(scores) / len(scores)
    variance = sum((score - avg_score) ** 2 for score in scores) / len(scores)
    
    # Lower variance = higher consistency
    consistency = max(0, 100 - (variance / avg_score if avg_score > 0 else 100))
    return round(consistency, 2)

def aggregate_team_data(team_id: int, series_id: int, squad_data: Dict[str, Any], match_id: int = None) -> TeamData:
    """
    Aggregate team data with Playing XI priority and support staff filtering
    Priority: 1) Playing XI -> 2) Squad (filtered) -> 3) Fallback
    """
    team_name = "Unknown Team"
    team_short_name = "UNK"
    players = []
    
    # Method 1: Try to get Playing XI first (highest priority for Dream11)
    all_match_players = None
    
    # Try Playing XI extraction first (this is what we want for Dream11)
    if match_id:
        try:
            playing_xi = extract_playing_xi_from_match_center(match_id, team_id)
            if playing_xi and len(playing_xi) >= 8:  # Minimum reasonable playing XI
                print(f"  ðŸŽ¯ Using Playing XI from match center for team {team_id}")
                for player_info in playing_xi:
                    if not is_support_staff(player_info):
                        player_data = extract_player_data(player_info, team_id, team_name)
                        players.append(player_data)
                
                print(f"  âœ… Found {len(players)} players from Playing XI")
                # Return immediately - Playing XI is what we want for Dream11
                team_data = TeamData(
                    team_id=team_id,
                    team_name=team_name,
                    team_short_name=team_short_name,
                    players=players
                )
                
                # Categorize players by role
                for player in players:
                    role = player.role.lower()
                    if 'wk' in role or 'wicket' in role or 'keeper' in role:
                        team_data.wicket_keepers.append(player)
                    elif 'allrounder' in role or 'all-rounder' in role or 'all rounder' in role:
                        team_data.all_rounders.append(player) 
                    elif 'bowl' in role:
                        team_data.bowlers.append(player)
                    elif 'bat' in role:
                        team_data.batsmen.append(player)
                    else:
                        # Default categorization for unknown roles - assume batsman
                        team_data.batsmen.append(player)
                
                return team_data
        except Exception as e:
            print(f"  âš ï¸ Playing XI extraction failed: {e}")
    
    # Method 2: Fallback to complete squad if Playing XI failed
    if not players and match_id:
        try:
            all_match_players = extract_all_players_from_match_center(match_id, team_id)
            if all_match_players and len(all_match_players) >= 8:
                print(f"  ðŸŽ¯ Using complete squad as fallback for team {team_id}")
                for player_info in all_match_players:
                    player_data = extract_player_data(player_info, team_id, team_name)
                    players.append(player_data)
                
                print(f"  âœ… Found {len(players)} players from complete squad (fallback)")
        except Exception as e:
            print(f"  âš ï¸ Complete squad extraction also failed: {e}")
    
    # Fallback: Try to get probable XI only
    playing_xi = None
    if match_id:
        try:
            playing_xi = extract_playing_xi_from_match_center(match_id, team_id)
        except Exception as e:
            print(f"  âš ï¸ Match center Playing XI extraction failed: {e}")
    
    # Skip the corrupted get_playing_xi API call as it may return wrong data
    if playing_xi:
        print(f"  ðŸŽ¯ Using Playing XI for team {team_id}")
        for player_info in playing_xi:
            if not is_support_staff(player_info):
                player_data = extract_player_data(player_info, team_id, team_name)
                players.append(player_data)
        
        if players:
            print(f"  âœ… Found {len(players)} players from Playing XI")
            # Only return early if we have a reasonable squad size (11+ players)
            if len(players) >= 11:
                team_data = TeamData(
                    team_id=team_id,
                    team_name=team_name,
                    team_short_name=team_short_name,
                    players=players
                )
                
                # Categorize players by role
                for player in players:
                    role = player.role.lower()
                    if 'wk' in role or 'wicket' in role or 'keeper' in role:
                        team_data.wicket_keepers.append(player)
                    elif 'allrounder' in role or 'all-rounder' in role or 'all rounder' in role:
                        team_data.all_rounders.append(player) 
                    elif 'bowl' in role:
                        team_data.bowlers.append(player)
                    elif 'bat' in role:
                        team_data.batsmen.append(player)
                    else:
                        # Default categorization for unknown roles - assume batsman
                        team_data.batsmen.append(player)
                
                return team_data
            else:
                print(f"  âš ï¸  Only {len(players)} players from Playing XI")
                print(f"  âš ï¸  SKIPPING squad APIs - detected data corruption (returning wrong team players)")
                print(f"  âš ï¸  Proceeding with available match center data only")
    
    # Check if no players were found after all attempts
    if not players:
        print(f"  âŒ No player details available for team {team_id} (only support staff found or no data available)")
        return TeamData(
            team_id=team_id,
            team_name=team_name,
            team_short_name=team_short_name,
            players=[],
            error="No player details available - only support staff or no data found"
        )
    
    team_data = TeamData(
        team_id=team_id,
        team_name=team_name,
        team_short_name=team_short_name,
        players=players
    )
    
    # Categorize players by role
    for player in players:
        role = player.role.lower()
        if 'wk' in role or 'wicket' in role or 'keeper' in role:
            team_data.wicket_keepers.append(player)
        elif 'allrounder' in role or 'all-rounder' in role or 'all rounder' in role:
            team_data.all_rounders.append(player) 
        elif 'bowl' in role:
            team_data.bowlers.append(player)
        elif 'bat' in role:
            team_data.batsmen.append(player)
        else:
            # Default categorization for unknown roles - assume batsman
            team_data.batsmen.append(player)
    
    return team_data

def aggregate_venue_data(venue_id: int, resolved_ids: Dict[str, Any]) -> VenueData:
    """
    Aggregate all venue-related data
    """
    venue_name = resolved_ids.get('venue', 'Unknown Venue')
    city = "Unknown"
    
    # Fetch venue statistics
    venue_stats = fetch_venue_stats(venue_id)
    
    # Fetch venue information
    venue_info = fetch_venue_info(venue_id)
    if venue_info and not venue_info.get('error'):
        city = venue_info.get('city', city)
        venue_name = venue_info.get('ground', venue_name)
    
    # Classify pitch archetype
    pitch_archetype = classify_pitch_archetype(venue_id, venue_stats)
    
    venue_data = VenueData(
        venue_id=venue_id,
        venue_name=venue_name,
        city=city,
        venue_stats=venue_stats if venue_stats and not venue_stats.get('error') else {},
        pitch_archetype=pitch_archetype
    )
    
    # Extract relevant venue metrics
    if venue_stats and not venue_stats.get('error'):
        venue_data.average_scores = {
            'overall': venue_stats.get('averageScore', 0),
            'first_innings': venue_stats.get('averageFirstInnings', 0),
            'second_innings': venue_stats.get('averageSecondInnings', 0)
        }
        
        venue_data.bowling_friendliness = {
            'pace': venue_stats.get('paceFriendliness', 'Medium'),
            'spin': venue_stats.get('spinFriendliness', 'Medium'),
            'overall': venue_stats.get('wicketTendency', 'Balanced')
        }
        
        venue_data.recent_matches = venue_stats.get('recentMatches', [])
    
    return venue_data

def aggregate_all_data(resolved_ids: Dict[str, Any]) -> MatchData:
    """
    Master function to aggregate all data required for Dream11 analysis with improved error handling
    
    Args:
        resolved_ids: Dictionary containing match, series, team, and venue IDs
    
    Returns:
        MatchData: Comprehensive data structure with all aggregated information
    """
    from datetime import datetime
    
    print("ðŸ”„ Starting comprehensive data aggregation...")
    
    # Show API optimization status
    if RATE_LIMITING_ENABLED:
        opt_status = get_api_optimization_status()
        rate_limit = opt_status["rate_limiting"]
        cache = opt_status["caching"]
        print(f"ðŸ›¡ï¸ API Status: {rate_limit['tokens_available']:.1f} tokens, {cache['hit_rate_percent']:.1f}% cache hit rate")
        
        if not rate_limit['can_make_request']:
            print(f"âš ï¸ Rate limited - wait {rate_limit['wait_time_seconds']:.1f}s or using cached data")
    else:
        print("âš ï¸ API optimization disabled - consider enabling for better performance")
    
    # Validate input data
    if not resolved_ids or not isinstance(resolved_ids, dict):
        print("âŒ Invalid or missing resolved_ids data")
        return None
    
    # Check for required fields
    required_fields = ['matchId', 'seriesId']
    missing_fields = [field for field in required_fields if field not in resolved_ids]
    if missing_fields:
        print(f"âŒ Missing required fields: {missing_fields}")
        return None
    
    errors = []
    
    # Extract IDs from resolved match data
    match_id = resolved_ids.get('matchId')
    series_id = resolved_ids.get('seriesId')
    team1_id = resolved_ids.get('team1Id')
    team2_id = resolved_ids.get('team2Id')
    venue_id = resolved_ids.get('venueId')
    match_format = resolved_ids.get('matchFormat', 'Unknown')
    
    print(f"ðŸ“Š Aggregating data for Match ID: {match_id}")
    print(f"ðŸŸï¸  Venue ID: {venue_id}")
    print(f"ðŸ Format: {match_format}")
    
    # Fetch match center data
    match_center_data = {}
    try:
        match_center_data = fetch_match_center(match_id)
        if match_center_data and match_center_data.get('error'):
            errors.append(f"Match center data error: {match_center_data['error']}")
            match_center_data = {}
    except Exception as e:
        errors.append(f"Error fetching match center data: {e}")
    
    # Fetch squad data
    print("ðŸ‘¥ Fetching squad information...")
    squad_data = {}
    try:
        squad_data = fetch_squads(series_id)
        if squad_data and squad_data.get('error'):
            errors.append(f"Squad data error: {squad_data['error']}")
    except Exception as e:
        errors.append(f"Error fetching squad data: {e}")
    
    # Aggregate team data
    team1_name = resolved_ids.get('team1Name', 'Team 1')
    team2_name = resolved_ids.get('team2Name', 'Team 2')
    
    print(f"ðŸ” Processing {team1_name} (ID: {team1_id})...")
    team1_data = aggregate_team_data(team1_id, series_id, squad_data, match_id)
    # Update team name from resolved data if not found in API
    if team1_data.team_name == "Unknown Team":
        team1_data.team_name = team1_name
        # Also update individual player team names
        for player in team1_data.players:
            player.team_name = team1_name
    
    # Check for team1 player data availability
    if team1_data.error:
        errors.append(f"Team 1 ({team1_name}): {team1_data.error}")
        print(f"  âŒ {team1_data.error}")
    
    print(f"ðŸ” Processing {team2_name} (ID: {team2_id})...")
    team2_data = aggregate_team_data(team2_id, series_id, squad_data, match_id)
    # Update team name from resolved data if not found in API
    if team2_data.team_name == "Unknown Team":
        team2_data.team_name = team2_name
        # Also update individual player team names
        for player in team2_data.players:
            player.team_name = team2_name
    
    # Check for team2 player data availability  
    if team2_data.error:
        errors.append(f"Team 2 ({team2_name}): {team2_data.error}")
        print(f"  âŒ {team2_data.error}")
    
    # Aggregate venue data
    print(f"ðŸŸï¸  Processing venue data...")
    venue_data = aggregate_venue_data(venue_id, resolved_ids)
    
    # Calculate data completeness score
    total_players = len(team1_data.players) + len(team2_data.players)
    players_with_stats = sum(1 for team in [team1_data, team2_data] 
                           for player in team.players 
                           if player.career_stats)
    
    completeness_score = (players_with_stats / total_players * 100) if total_players > 0 else 0
    
    # Create comprehensive match data structure
    match_data = MatchData(
        match_id=match_id,
        series_id=series_id,
        match_format=match_format,
        team1=team1_data,
        team2=team2_data,
        venue=venue_data,
        match_center_data=match_center_data,
        data_collection_timestamp=datetime.now().isoformat(),
        data_completeness_score=round(completeness_score, 2),
        errors_encountered=errors
    )
    
    print(f"âœ… Data aggregation complete!")
    print(f"ðŸ“ˆ Data completeness: {match_data.data_completeness_score}%")
    print(f"ðŸ‘¥ Total players processed: {total_players}")
    print(f"ðŸŸï¸  Pitch archetype: {venue_data.pitch_archetype}")
    
    # Show final API optimization metrics
    if RATE_LIMITING_ENABLED:
        final_status = get_api_optimization_status()
        final_cache = final_status["caching"]
        final_perf = final_status["performance_summary"]
        print(f"    ðŸŒ API Calls Made: {final_status['rate_limiting']['total_requests_made']}")
        print(f"    ðŸ’¾ Cache Hits: {final_cache['memory_hits'] + final_cache['disk_hits']}")
        print(f"    ðŸ’° Cost Savings: {final_perf['cost_savings_percent']:.1f}%")
    
    if errors:
        print(f"âš ï¸  {len(errors)} errors encountered during aggregation")
    
    return match_data

def print_aggregation_summary(match_data: MatchData) -> None:
    """
    Print a comprehensive summary of aggregated data
    """
    print("\n" + "="*60)
    print("ðŸ“‹ DATA AGGREGATION SUMMARY")
    print("="*60)
    
    print(f"ðŸ Match: {match_data.team1.team_name} vs {match_data.team2.team_name}")
    print(f"ðŸŸï¸  Venue: {match_data.venue.venue_name} ({match_data.venue.city})")
    print(f"ðŸŽ¯ Format: {match_data.match_format}")
    print(f"ðŸŒ± Pitch: {match_data.venue.pitch_archetype}")
    print(f"ðŸ“Š Data Quality: {match_data.data_completeness_score}%")
    
    print(f"\nðŸ‘¥ TEAM COMPOSITION:")
    for i, team in enumerate([match_data.team1, match_data.team2], 1):
        print(f"  Team {i}: {team.team_name}")
        print(f"    ðŸ Batsmen: {len(team.batsmen)}")
        print(f"    âš¡ Bowlers: {len(team.bowlers)}")
        print(f"    ðŸ”„ All-rounders: {len(team.all_rounders)}")
        print(f"    ðŸ§¤ Wicket-keepers: {len(team.wicket_keepers)}")
    
    if match_data.errors_encountered:
        print(f"\nâš ï¸  ERRORS ENCOUNTERED:")
        for error in match_data.errors_encountered:
            print(f"    â€¢ {error}")
    
    print("="*60)

def extract_all_players_from_match_center(match_id: int, team_id: int) -> List[Dict[str, Any]]:
    """
    Extract ALL players from match center data (both probable XI and substitutes)
    This is used when squad APIs are corrupted and we need complete squad data
    """
    try:
        from utils.api_client import fetch_match_center
        
        match_data = fetch_match_center(match_id)
        if not match_data or 'matchInfo' not in match_data:
            return None
            
        match_info = match_data['matchInfo']
        
        # Find the correct team
        team_key = None
        if 'team1' in match_info and match_info['team1'].get('id') == team_id:
            team_key = 'team1'
        elif 'team2' in match_info and match_info['team2'].get('id') == team_id:
            team_key = 'team2'
        
        if not team_key or 'playerDetails' not in match_info[team_key]:
            return None
            
        all_players = match_info[team_key]['playerDetails']
        valid_players = []
        
        for player in all_players:
            # Include ALL players (both substitute true/false) but filter support staff
            if is_support_staff(player):
                continue
                
            # Additional validation: Only include actual cricket players with valid roles
            role = str(player.get('role', '')).lower()
            player_name = str(player.get('name', '')).lower()
            
            # Define valid cricket roles more comprehensively
            cricket_roles = [
                'batsman', 'bowler', 'allrounder', 'all-rounder', 'all rounder',
                'wk-batsman', 'wicket-keeper', 'wicketkeeper', 'wk', 
                'batting allrounder', 'bowling allrounder', 'right-hand bat',
                'left-hand bat', 'right-arm fast', 'left-arm fast', 'right-arm medium',
                'left-arm medium', 'right-arm off break', 'left-arm orthodox',
                'leg break googly', 'slow left-arm orthodox'
            ]
            
            # Check if player has a valid cricket role
            has_valid_role = any(cricket_role in role for cricket_role in cricket_roles)
            
            # Additional check: Exclude obvious non-players by name patterns
            non_player_names = ['coach', 'manager', 'analyst', 'physio', 'doctor', 'trainer']
            is_non_player = any(pattern in player_name for pattern in non_player_names)
            
            if has_valid_role and not is_non_player:
                valid_players.append(player)
                print(f"    âœ… Added squad player: {player.get('name', 'Unknown')} ({role}) [substitute: {player.get('substitute', 'N/A')}]")
        
        if valid_players:
            print(f"  ðŸŽ¯ Extracted {len(valid_players)} total squad players from match center")
            return valid_players
        else:
            print(f"  âŒ No valid players found in match center")
            return None
            
    except Exception as e:
        print(f"  âŒ Error extracting all players from match center: {e}")
        return None

def extract_playing_xi_from_match_center(match_id: int, team_id: int) -> List[Dict[str, Any]]:
    """
    Extract Playing XI from match center data by filtering out support staff and bench players
    Returns list of actual playing XI players (should be 11 players)
    """
    try:
        from utils.api_client import fetch_match_center
        
        match_data = fetch_match_center(match_id)
        if not match_data or 'matchInfo' not in match_data:
            return None
            
        match_info = match_data['matchInfo']
        
        # Find the correct team
        team_key = None
        if 'team1' in match_info and match_info['team1'].get('id') == team_id:
            team_key = 'team1'
        elif 'team2' in match_info and match_info['team2'].get('id') == team_id:
            team_key = 'team2'
        
        if not team_key or 'playerDetails' not in match_info[team_key]:
            return None
            
        all_players = match_info[team_key]['playerDetails']
        playing_xi = []
        
        for player in all_players:
            # Only include probable XI players (substitute: false indicates probable playing XI)
            if player.get('substitute', True):  # Skip if substitute=True (bench players)
                continue
                
            # Skip support staff using our enhanced filter
            if is_support_staff(player):
                continue
                
            # Additional validation: Only include actual cricket players with valid roles
            role = str(player.get('role', '')).lower()
            player_name = str(player.get('name', '')).lower()
            
            # Define valid cricket roles more comprehensively
            cricket_roles = [
                'batsman', 'bowler', 'allrounder', 'all-rounder', 'all rounder',
                'wk-batsman', 'wicket-keeper', 'wicketkeeper', 'wk', 
                'batting allrounder', 'bowling allrounder', 'right-hand bat',
                'left-hand bat', 'right-arm fast', 'left-arm fast', 'right-arm medium',
                'left-arm medium', 'right-arm off break', 'left-arm orthodox',
                'leg break googly', 'slow left-arm orthodox'
            ]
            
            # Check if player has a valid cricket role
            has_valid_role = any(cricket_role in role for cricket_role in cricket_roles)
            
            # Additional check: Exclude obvious non-players by name patterns
            non_player_names = ['coach', 'manager', 'analyst', 'physio', 'doctor', 'trainer']
            is_non_player = any(pattern in player_name for pattern in non_player_names)
            
            if has_valid_role and not is_non_player:
                playing_xi.append(player)
                print(f"    âœ… Added probable XI player: {player.get('name', 'Unknown')} ({role})")
        
        # Limit to 11 players maximum (in case there are extras)
        if len(playing_xi) > 11:
            print(f"  âš ï¸  Found {len(playing_xi)} players, limiting to 11")
            playing_xi = playing_xi[:11]
            
        if playing_xi:
            print(f"  ðŸŽ¯ Extracted {len(playing_xi)} Playing XI players from match center")
            return playing_xi
        else:
            print(f"  âŒ No valid Playing XI found after filtering")
            return None
            
    except Exception as e:
        print(f"  âŒ Error extracting Playing XI from match center: {e}")
        return None

def get_playing_xi(series_id: int, team_id: int) -> List[Dict[str, Any]]:
    """
    Try to get Playing XI for a team from multiple API endpoints
    Returns list of player info dictionaries or None if not found
    """
    try:
        from utils.api_client import fetch_match_center, API_BASE_URL, API_HEADERS
        import requests
        
        # Method 1: Try extracting Playing XI from match center using the series_id as match_id
        try:
            playing_xi = extract_playing_xi_from_match_center(series_id, team_id)
            if playing_xi:
                return playing_xi
        except Exception as e:
            print(f"  âš ï¸ Match center Playing XI extraction failed: {e}")
        
        # Method 1b: Try with team_id as match_id (fallback)
        try:
            playing_xi = extract_playing_xi_from_match_center(team_id, team_id)
            if playing_xi:
                return playing_xi
        except Exception as e:
            print(f"  âš ï¸ Match center Playing XI fallback failed: {e}")
        
        # Method 2: Try direct Playing XI API endpoint
        try:
            url = f"{API_BASE_URL}/matchcentre/v1/series/{series_id}/squads"
            response = requests.get(url, headers=API_HEADERS, timeout=10)
            if response.status_code == 200:
                data = response.json()
                # Look for Playing XI data in squads response
                squads = data.get('squads', [])
                for squad in squads:
                    if squad.get('teamId') == team_id and squad.get('isPlayingXI'):
                        players = squad.get('player', [])
                        if players:
                            print(f"  ðŸŽ¯ Found Playing XI from squads API for team {team_id}")
                            return players
        except Exception as e:
            print(f"  âš ï¸ Direct Playing XI API failed: {e}")
        
        # Method 3: Try team-specific Playing XI endpoint
        try:
            url = f"{API_BASE_URL}/matchcentre/v1/series/{series_id}/teams/{team_id}/playingxi"
            response = requests.get(url, headers=API_HEADERS, timeout=10)
            if response.status_code == 200:
                data = response.json()
                players = data.get('players', [])
                if players:
                    print(f"  ðŸŽ¯ Found Playing XI from team API for team {team_id}")
                    return players
        except Exception as e:
            print(f"  âš ï¸ Team Playing XI API failed: {e}")
        
        print(f"  âŒ No Playing XI found for team {team_id}")
        return None
        
    except Exception as e:
        print(f"  âŒ Error getting Playing XI: {e}")
        return None

def is_support_staff(player_info: Dict[str, Any]) -> bool:
    """
    Determine if a player is support staff (coach, manager, etc.)
    Returns True if player should be filtered out
    """
    if not player_info:
        return True
    
    # Check role field
    role = str(player_info.get('role', '')).lower()
    name = str(player_info.get('name', '')).lower()
    
    # Support staff roles to filter out (comprehensive list)
    support_roles = [
        'coach', 'manager', 'support', 'staff', 'analyst', 
        'physiotherapist', 'physio', 'trainer', 'assistant',
        'media', 'doctor', 'medical', 'head coach', 'bowling coach',
        'batting coach', 'fielding coach', 'team manager',
        'assistant coach', 'strength and conditioning', 'video analyst',
        'team doctor', 'chief selector', 'selector', 'psychologist',
        'massage therapist', 'kit manager', 'security manager',
        'welfare officer', 'team operations', 'logistics', 'administrator',
        'coordinator', 'liaison', 'consultant', 'specialist',
        'performance analyst', 'fitness coach', 'nutritionist'
    ]
    
    # Check if role contains any support staff keywords
    for support_role in support_roles:
        if support_role in role:
            print(f"    ðŸš« Filtering support staff: {player_info.get('name', 'Unknown')} ({role})")
            return True
    
    # Check name for obvious support staff indicators
    support_name_indicators = ['coach', 'manager', 'dr.', 'dr ', 'physio']
    for indicator in support_name_indicators:
        if indicator in name:
            print(f"    ðŸš« Filtering support staff by name: {player_info.get('name', 'Unknown')}")
            return True
    
    # If no clear role is specified, assume it's a player
    return False